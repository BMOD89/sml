#pragma once

#include "esphome/core/component.h"
#include "esphome/components/sensor/sensor.h"
#include "esphome/components/text_sensor/text_sensor.h"
#include "esphome/components/uart/uart.h"
#include "esphome/core/log.h"
#include "esphome/core/defines.h"

#include <sml/sml_file.h>
#include "./sml_mapping.h"
namespace esphome {
namespace sml_ {

static constexpr uint32_t MAX_TELEGRAM_LENGTH = 1500;
static constexpr uint32_t POLL_TIMEOUT = 1000;
const char HEADER_PATTERN[8] = {0x1B, 0x1B, 0x1B, 0x1B, 0x01, 0x01, 0x01, 0x01};
const char FOOTER_PATTERN[5] = {0x1B, 0x1B, 0x1B, 0x1B, 0x1A};

// using namespace sml::fields;

// SML_**_LIST generated by ESPHome and written in esphome/core/defines

#if defined(SML_SENSOR_LIST) && defined(SML_TEXT_SENSOR_LIST)
#define SML_BOTH ,
#else
#define SML_BOTH
#endif

#ifndef SML_SENSOR_LIST
#define SML_SENSOR_LIST(F, SEP)
#endif

#ifndef SML_TEXT_SENSOR_LIST
#define SML_TEXT_SENSOR_LIST(F, SEP)
#endif

#define SML_DATA_SENSOR(s) s
#define COMMA ,

class Sml : public Component, public uart::UARTDevice {
 public:
  Sml(uart::UARTComponent* uart) : uart::UARTDevice(uart) {}

  void loop() override;

  bool parse_telegram();

  void publish_sensors(sml_file *file) {
#define SML_PUBLISH_SENSOR(s) \
  if (this->s_##s##_ != nullptr) \
  { \
    for (int i = 0; i < file->messages_len; i++) \
    { \
      sml_message *message = file->messages[i]; \
      if (*message->message_body->tag == SML_MESSAGE_GET_LIST_RESPONSE) \
      { \
        sml_list *entry; \
        sml_get_list_response *body; \
        body = (sml_get_list_response *)message->message_body->data; \
        for (entry = body->val_list; entry != NULL; entry = entry->next) \
        { \
          if (!entry->value) \
          { \
              ESP_LOGV("sml", "Error in data stream. entry->value should not be NULL. Skipping this."); \
              continue; \
          } \
          if (((entry->value->type & SML_TYPE_FIELD) == SML_TYPE_INTEGER) || \
              ((entry->value->type & SML_TYPE_FIELD) == SML_TYPE_UNSIGNED)) \
          { \
            if (sml_fields::sml_map_##s[0] == entry->obj_name->str[0] && \
                sml_fields::sml_map_##s[1] == entry->obj_name->str[1] && \
                sml_fields::sml_map_##s[2] == entry->obj_name->str[2] && \
                sml_fields::sml_map_##s[3] == entry->obj_name->str[3] && \
                sml_fields::sml_map_##s[4] == entry->obj_name->str[4]) \
              s_##s##_->publish_state(sml_value_to_double(entry->value)); \
          } \
        } \
      } \
    } \
  }
    SML_SENSOR_LIST(SML_PUBLISH_SENSOR, )

#define SML_PUBLISH_TEXT_SENSOR(s) \
  if (data.s##_present && this->s_##s##_ != nullptr) \
    s_##s##_->publish_state(data.s.c_str());
    SML_TEXT_SENSOR_LIST(SML_PUBLISH_TEXT_SENSOR, )
  };

  void dump_config() override;

// Sensor setters
#define SML_SET_SENSOR(s) \
  void set_##s(sensor::Sensor* sensor) { s_##s##_ = sensor; }
  SML_SENSOR_LIST(SML_SET_SENSOR, )

#define SML_SET_TEXT_SENSOR(s) \
  void set_##s(text_sensor::TextSensor* sensor) { s_##s##_ = sensor; }
  SML_TEXT_SENSOR_LIST(SML_SET_TEXT_SENSOR, )

 protected:
  void receive_telegram();

  // Telegram buffer
  char telegram_[MAX_TELEGRAM_LENGTH];
  int telegram_len_{0};
  int i_header_{0};
  int i_footer_{0};


  // Header and Footer patterns
  

  // Serial parser
  bool header_found_{false};

// Sensor member pointers
#define SML_DECLARE_SENSOR(s) sensor::Sensor* s_##s##_{nullptr};
  SML_SENSOR_LIST(SML_DECLARE_SENSOR, )

#define SML_DECLARE_TEXT_SENSOR(s) text_sensor::TextSensor* s_##s##_{nullptr};
  SML_TEXT_SENSOR_LIST(SML_DECLARE_TEXT_SENSOR, )

  std::vector<uint8_t> decryption_key_{};
};
}  // namespace sml_
}  // namespace esphome
